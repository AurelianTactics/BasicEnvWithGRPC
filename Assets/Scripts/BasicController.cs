using UnityEngine;
using UnityEngine.SceneManagement;
//using Unity.MLAgents;
using UnityEngine.Serialization;
using AurelianTactics.BlackBoxRL;
using System.Threading.Tasks;
using System.Threading.Tasks;
using System;
using System.Collections;

/// <summary>
/// An example of how to use ML-Agents without inheriting from the Agent class.
/// Observations are generated by the attached SensorComponent, and the actions
/// are retrieved from the Agent.
/// </summary>
public class BasicController : MonoBehaviour
{
    public float timeBetweenDecisionsAtInference;
    float m_TimeSinceDecision;
    [FormerlySerializedAs("m_Position")]
    [HideInInspector]
    public int position;
    const int k_SmallGoalPosition = 7;
    const int k_LargeGoalPosition = 17;
    public GameObject largeGoal;
    public GameObject smallGoal;
    const int k_MinPosition = 0;
    const int k_MaxPosition = 20;
    public const int k_Extents = k_MaxPosition - k_MinPosition;

    //Agent m_Agent;

    public bool isDone; //adding this to work with Task architecture
    public float lastReward; //adding this to work with Task architecture

    public void OnEnable()
    {
        //m_Agent = GetComponent<Agent>();
        position = 10;
        transform.position = new Vector3(position - 10f, 0f, 0f);
        smallGoal.transform.position = new Vector3(k_SmallGoalPosition - 10f, 0f, 0f);
        largeGoal.transform.position = new Vector3(k_LargeGoalPosition - 10f, 0f, 0f);
        isDone = false;
        lastReward = 0.0f;
	}

	//dummy code to test that MoveAgent works
	//private void Update()
	//{
	//	if(position != 20)
	//	{
	//		position = 20;
	//		StartCoroutine(MoveAgent(20));
	//	}
	//}

	/// <summary>
	/// Controls the movement of the GameObject based on the actions received.
	/// </summary>
	/// <param name="direction"></param>
	async Task<string> MoveDirection(int direction)
    {
		Debug.Log(" top of move Direction, direction and position are " + direction + " " + position);
        position += direction;
        if (position < k_MinPosition) { position = k_MinPosition; }
        if (position > k_MaxPosition) { position = k_MaxPosition; }

		//gameObject.transform.position = new Vector3(position - 10f, 0f, 0f);
		UnityMainThreadDispatcher.Instance().Enqueue(MoveAgent(position));

		//m_Agent.AddReward(-0.01f);
		lastReward = -0.01f;

        if (position == k_SmallGoalPosition)
        {
            //m_Agent.AddReward(0.1f);
            //m_Agent.EndEpisode();
            //ResetAgent(); //calling from AgentSession through Task
            isDone = true;
            lastReward += 0.1f;
        }

        if (position == k_LargeGoalPosition)
        {
            //m_Agent.AddReward(1f);
            //m_Agent.EndEpisode();
            //ResetAgent(); //calling from AgentSession through Task
            isDone = true;
            lastReward += 1f;
        }

		Debug.Log("TEST bottom of move Direction, direction and position are " + direction + " " + position);
		//to do: try/catch block and step message
		return "stepMessage";
	}

    public async Task<string> ResetAgent(int pos=10)
    {
		try
		{
			position = pos;

			//these things cause the grpc to error out
			//UnityMainThreadDispatcher.Instance().Enqueue(AddTMPTextOnMainThread(textData));
			UnityMainThreadDispatcher.Instance().Enqueue(MoveAgent(position));
			//StartCoroutine(MoveAgent(position));
			//gameObject.transform.position = new Vector3(position - 10f, 0f, 0f);
			// This is a very inefficient way to reset the scene. Used here for testing.
			//SceneManager.LoadScene(SceneManager.GetActiveScene().name);

			//m_Agent = null; // LoadScene only takes effect at the next Update.
			// We set the Agent to null to avoid using the Agent before the reload
			isDone = false;
			lastReward = 0.0f;
			Debug.Log("ResetAgent worked");
			return "";
		}
		catch(Exception e)
		{
			Debug.Log("ERROR in ResetAgent caught an exception " + e);
			return "error";
		}
    }

	IEnumerator MoveAgent(int pos)
	{
		Debug.Log("TEST: top of MoveAgent " + position);
		gameObject.transform.position = new Vector3(position - 10f, 0f, 0f);
		Debug.Log("TEST: bottom of MoveAgent " + position);
		yield break;
	}


	//public void FixedUpdate()
 //   {
 //       WaitTimeInference();
 //   }

 //   void WaitTimeInference()
 //   {
	//	if (m_Agent == null)
	//	{
	//		return;
	//	}
	//	if (Academy.Instance.IsCommunicatorOn)
	//	{
	//		m_Agent?.RequestDecision();
	//	}
	//	else
	//	{
	//		if (m_TimeSinceDecision >= timeBetweenDecisionsAtInference)
	//		{
	//			m_TimeSinceDecision = 0f;
	//			m_Agent?.RequestDecision();
	//		}
	//		else
	//		{
	//			m_TimeSinceDecision += Time.fixedDeltaTime;
	//		}
	//	}
	//}

    /// <summary>
    /// basicController assumes actions are -1, 0, 1 and moves object accordingly
    /// my actions are 0 (no action (ie 0), 1 (right ie 1), and 2 (left ie -1)
    /// </summary>
    /// <param name="action"></param>
    public async Task<string> ConvertActionToDirectionAndMove(int action)
    {
        if (action == 2)
            action = -1;
        var stepMessage = await MoveDirection(action);
		return stepMessage;
    }


}
